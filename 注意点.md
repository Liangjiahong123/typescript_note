# 命名冲突

- 对于 `.ts` 文件来说，如果没有顶级导入或导出声明，该文件被视为其内容在全局范围内可用的脚本

```typescript
// a.ts
let name:string = 'gogo'
```

```typescript
// b.ts
let name:string = 'tony'
```

- 以上情况会造成命名冲突，使用 `export {}` 语句作为模块进行空导出，表明是 `ES` 模块，有自己的作用域

```typescript
// b.ts
let name:string = 'tony'
export {}
```

# 类型注解

- 例如：使用 `stirng` 和 `String` 进行类型注解，有什么不同？

```typescript
let name:string = 'tony'

let name:String = 'tony'
```

- `stirng` 是 `typescript` 中标准的原生字符串类型
- `String` 是 `JavaScript` 中的包装字符串的对象类型

# 可选与联合

- 当函数参数是可选类型时，其本质上是 `类型|undefined` 的联合类型

```typescript
function foo(name?:string){
 console.log(name)
}
```

- 如上所示，此时形参 `name` 的类型是 `string|undefined`

![1685033497373](images/1685033497373.png)

- 调用函数时可以不传参数
- 但是如果写成 `string|undefined`而不是可选形式，则参数是必传的

```typescript
// 此时参数必须传递，否则编译不通过
function foo(name:string | undefined){
  console.log(name);
}
```

# 类型擦除

- `typescript` 在编译过程中批注的内容和接口会在运行时利用工具擦除

```typescript
interface IPerson {
  name: string
  age: number
}

const person = {
  name: "Tony",
  age: 18,
  address: '广东省深圳市南山区'
}

const personInfo: IPerson = person
```

- 如上面代码所示，常量 `person` 会进行类型推断，其中会有 `{address: string}`，当把 `person` 赋值给`personInfo` 时，编译器会把多余的属性进行**擦除(freshness)**，擦除后若依然满足 `IPerson` 接口规定的类型，则可以赋值

- 当擦除后不满足接口规定时，则不会通过编译

![1685183470293](images/1685183470293.png)